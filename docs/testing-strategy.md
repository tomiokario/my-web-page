# テスト戦略

このドキュメントでは、my-web-pageプロジェクトのテスト戦略、テストの書き方、およびテスト実行方法について説明します。

## 概要

my-web-pageでは、Jest と React Testing Library を使用して、コンポーネント、フック、ユーティリティ関数のテストを行っています。テストは `src/__tests__` ディレクトリに配置されており、各コンポーネントやフックに対応するテストファイルが存在します。

テスト戦略の主な目的は以下の通りです：

1. コードの品質と信頼性を確保する
2. リグレッションを防止する
3. コンポーネントの仕様を文書化する
4. リファクタリングを安全に行えるようにする

## テスト構造

テストファイルは以下の命名規則に従っています：

- コンポーネントテスト: `ComponentName.test.tsx`
- フックテスト: `useHookName.test.ts`
- ユーティリティテスト: `utilityName.test.ts`

テストファイルは `src/__tests__` ディレクトリに配置されています：

```
src/__tests__/
├── ActiveFilters.test.tsx
├── App.test.tsx
├── csvToJson.test.ts
├── FilterDropdown.test.tsx
├── Footer.test.tsx
├── Header.test.tsx
├── LanguageContext.test.tsx
├── markdownLoader.test.ts
├── PublicationGroup.test.tsx
├── PublicationItem.test.tsx
├── Publications.test.tsx
├── PublicationsView.test.tsx
├── SubHeader.test.tsx
├── useFilters.test.ts
└── usePublications.test.ts
```

## テストの種類

プロジェクトでは以下の種類のテストを実施しています：

1. **単体テスト**: 個々のコンポーネント、フック、ユーティリティ関数の機能をテスト
2. **統合テスト**: 複数のコンポーネントやフックの連携をテスト

### 実際のコードベースにおける単体テストと統合テスト

#### 単体テスト

以下のテストファイルは、単一のコンポーネント、フック、またはユーティリティ関数の機能をテストする単体テストです：

- **useFilters.test.ts**: useFiltersフックの機能（フィルターオプションの抽出、フィルタリング、ドロップダウンの開閉、フィルターのリセット）を個別にテストします。

- **usePublications.test.ts**: usePublicationsフックの機能（年の抽出、出版物データの整形、ソート、グループ化）を個別にテストします。

- **PublicationsView.test.tsx**: 子コンポーネント（PublicationGroup）をモックして、PublicationsViewコンポーネントの機能をテストします。

- **ActiveFilters.test.tsx**: ActiveFiltersコンポーネントの機能（フィルタータグの表示、リセットボタンのクリックなど）をテストします。

- **FilterDropdown.test.tsx**: FilterDropdownコンポーネントの機能（ドロップダウンの表示、チェックボックスの選択など）をテストします。

- **PublicationItem.test.tsx**: PublicationItemコンポーネントの機能（出版物情報の表示、タグの表示など）をテストします。

- **csvToJson.test.ts**: csvToJson関数の機能（CSVデータのJSON変換）をテストします。

- **markdownLoader.test.ts**: markdownLoader関数の機能（Markdownファイルの読み込み）をテストします。

#### 統合テスト

以下のテストファイルは、複数のコンポーネントやフックが連携して動作することをテストする統合テストです：

- **Publications.test.tsx**: Publicationsコンポーネントと言語コンテキスト、フィルタリング機能などの連携をテストします。実際のLanguageProviderを使用し、ユーザーインタラクションの一連の流れをテストします。

- **LanguageContext.test.tsx**: LanguageContextとそれを使用するコンポーネントの連携をテストします。実際のuseLanguageフックを使用して、言語の切り替え機能と副作用をテストします。

- **App.test.tsx**: アプリケーションのルートコンポーネントであるAppコンポーネントと、それに含まれる主要コンポーネント（ヘッダー、メインコンテンツ、フッターなど）の連携をテストします。

## テストの書き方

### コンポーネントテスト

コンポーネントテストでは、React Testing Libraryを使用して、ユーザーの視点からコンポーネントの動作をテストします。

(コード例は削除されました)

### フックテスト

フックテストでは、`@testing-library/react` の `renderHook` 関数を使用して、フックの動作をテストします。`act` を使用して状態更新をラップします。

(コード例は削除されました)

### ユーティリティ関数テスト

ユーティリティ関数のテストでは、関数の入力と出力を検証します。Jest のマッチャー (`toBe`, `toThrow` など) を使用してアサーションを行います。

(コード例は削除されました)

## モックの使用

テストでは、Jest のモック機能 (`jest.mock`, `jest.fn`) を使用して、外部依存関係（モジュール、コンポーネント、関数）をモックし、テストを分離し、予測可能にします。

### モジュールのモック

(コード例は削除されました)

### コンポーネントのモック

(コード例は削除されました)

### 関数のモック

(コード例は削除されました)

## テスト例

(テスト例は削除されました)

## テストの実行

### すべてのテストを実行

```bash
npm test
```

### 特定のテストファイルを実行

```bash
# 例: ComponentName.test.tsx を実行
npm test -- ComponentName.test.tsx
# または、ファイル名の一部を指定
npm test -- ComponentName
```

### テストカバレッジを確認

```bash
npm test -- --coverage
```

## テスト戦略のベストプラクティス

1. **AAA（Arrange-Act-Assert）パターン**に従ってテストを記述する
   - Arrange: テストの前提条件を設定
   - Act: テスト対象の機能を実行
   - Assert: 結果を検証

2. **ユーザー視点でテストを書く**
   - 実装の詳細ではなく、ユーザーの操作と期待される結果に焦点を当てる
   - React Testing Libraryの `getByRole`, `getByText` などのクエリを使用する

3. **モックは必要最小限に留める**
   - 外部依存関係のみをモックし、テスト対象のコードはできるだけ実際のコードを使用する
   - モックが多すぎると、テストの信頼性が低下する

4. **テストは独立していて、他のテストに依存しないようにする**
   - 各テストは独立して実行できるようにする
   - テスト間で状態を共有しない

5. **エッジケースをテストする**
   - 空の配列、null、undefined などの特殊なケースをテストする
   - エラーケースもテストする

6. **テストは読みやすく、メンテナンスしやすくする**
   - テスト名は「何をテストしているか」が明確にわかるようにする
   - 複雑なセットアップは関数に抽出する

## テストの追加方法

新しい機能やコンポーネントを追加する場合は、以下の手順に従ってテストを追加してください：

1. `src/__tests__` ディレクトリに新しいテストファイルを作成する
2. 適切なテストケースを記述する
3. `npm test` を実行してテストが正常に動作することを確認する
4. 必要に応じてテストを修正・追加する

## 注意点

- テストは開発プロセスの一部として継続的に実行し、コードの品質を維持する
- テストカバレッジは重要だが、100%のカバレッジを目指すよりも、重要な機能と複雑なロジックをカバーすることを優先する
- テストが失敗した場合は、テストを修正する前にコードのバグを修正することを検討する